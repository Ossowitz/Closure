![Groovy-logo.svg.png](src%2Fmain%2Fresources%2Fphoto%2FGroovy-logo.svg.png)

# Groovy compiler

![Blank diagram.png](src%2Fmain%2Fresources%2Fphoto%2FBlank%20diagram.png)

Когда используется **groovyc** и на вход подаётся *FirstScript.groovy*, в Groovy есть **Parser**, который парсит
*FirstScript.groovy* класс, добавляет AST transformations (что-то вроде аналогии библиотеки Lombok). После чего,
исходный код попадает в **Class generator**, который занимается преобразованием того, что у нас вышло из **Parser** в
обычный байт-код. И результат его работы мы видим на нашем диске - *FirstScript.class* байт-код.

В свою очередь, когда мы **groovy** подаём тот же *FirstScript.groovy*, происходит то же самое: переходит в **Parser**,
парсит *FirstScript.groovy* и передаёт его в **Class generator**, который в свою очередь, преобразовывает в байт-код.
Но в этом случае он не сохраняет результат работы на диск - он хранит их в памяти. И после чего вызывает что-то вроде
эквивалента **java** FirstScript. То есть, программа, которая принимает на вход байт-код и исполняет его.

Естественно здесь есть нюансы: FirstScript не может так просто запуститься, потому что на выходе мы получаем особенные
классы, более того, Java должна знать, откуда их брать. То есть, должен быть правильно указан ClassPath и многое другое.
Следовательно, используются специфичные ClassLoader'ы - это GroovyClassLoader'ы, которые и помогают загружать все наши
Groovy-классы, которые были скомпилированы в байт-код.